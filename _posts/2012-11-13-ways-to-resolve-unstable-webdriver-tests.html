---
layout: post
title: Ways to resolve unstable Webdriver tests
date: 2012-11-13 14:20:21.000000000 +01:00
type: post
published: true
status: publish
categories:
- Testing
tags: []
meta:
  _edit_last: '1'
author:
  login: michael
  email: thelinmichael@gmail.com
  display_name: michael
  first_name: ''
  last_name: ''
---
<p>We're constantly having issues with unstable <a title="http://code.google.com/p/selenium/" href="http://code.google.com/p/selenium/">Webdriver</a> tests for different reasons. Most times, it seems to come down to the way the test is written and not the way Webdriver works. Below, I'll list some of the things that I try to have in mind while writing a test. I'll begin with the stuff that are general test principles, and continue with what's Webdriver specific. I'll use Webdriver code to illustrate examples.</p>
<h3>1. General testing practices</h3>
<h4>1.1. Mock external services</h4>
<p>When going through a test regression suit that took 30 minutes to run, a colleague and I found that every webpage was making a call to Google Analytics, causing the test suite to take much longer time than necessary due to network latency. (Another unwanted side effect was that the analytics got watered down by the artificial hits from the tests). Mocking the Google Analytics response shaved several minutes off of the time it took to run the regression suite. It also made the tests more stable. In case our own connection went down, or indeed if Google's did, the tests would take even longer to run in the best case, or in the worst case they would fail completely.</p>
<p>In essence, avoid this kind of flakiness by <strong>never making calls to an external services unless you really have to</strong>, like in an end-to-end-tests. In most cases you can <strong>mock the response</strong>, and it will make the test suite run faster as you don't have any network latency, and run more reliably since they don't depend on a network connection to the external service.</p>
<p>Using external services in a unit test is also an indication that you're testing more than the actual unit since you cannot really control the output from the external service. Avoid writing tests that are hybrids of unit tests and end-to-end tests.</p>
<p>Each web page contained an include of a JavaScript file that made a call to Google Analytics, so that we could track visitors around the site.</p>
<pre class="noescape prettyprint">&lt;script language="javascript" src="/javascript/googleAnalytics.js"&gt;&lt;/script&gt;</pre>
<p>So we just changed the path of this file to be configurable, and created an empty JavaScript file that can be used when running tests. <a title="http://www.playframework.org/" href="http://www.playframework.org/">Play Framework 1.x</a> uses Groovy as a template language, so the code would look like this:</p>
<pre class="noescape prettyprint">&lt;script language="javascript" src="${googleAnalyticsFilepath}"&gt;&lt;/script&gt;</pre>
<p>In application.conf, Play Framework project's main configuration file, we'd set the path to the regular Google Analytics JavaScript file.</p>
<pre class="noescape prettyprint">googleAnalyticsFilepath=/javascript/googleAnalytics.js</pre>
<p>In test.conf, which is run after application.conf and overwrites any configuration that has been set earlier, we'd set the property to point at the empty test file.</p>
<pre class="noescape prettyprint">googleAnalyticsFilepath=/test/javascript/googleAnalytics.js</pre>
<p>The bad part is that you add to the amount of configuration needed to set up the project. But it's better than polluting your code with test code, like this.</p>
<pre class="noescape prettyprint">#{if play.Play.runingInTestMode()}
   &lt;script language="javascript" src="/javascript/googleAnalytics.js"&gt;&lt;/script&gt;
#{/if}
#{else}
   &lt;script language="javascript" src="/test/javascript/googleAnalytics.js"&gt;&lt;/script&gt;
#{/else}</pre>
<p><em>By the way, that isn't a typo. runingInTestMode() is actually a function in Play Framework 1.x. </em></p>
<h4><strong>1.2. Poll for asynchronous responses</strong></h4>
<p>Most websites these days contain Ajax calls, and if you're making an end-to-end test in Webdriver, you are likely to have issues with it. The problem with asynchronus functions is that you never know how long it takes before the they're completed and change whatever it is you're testing.</p>
<p>Here's a few lines of code that checks for changes that should occur when a button is clicked.</p>
<pre class="noescape prettyprint">driver.get("http://www.example.com/");

WebElement hasChanged = driver.findElement(By.id("somethingThatShouldChange"));
assertThat(hasChanged, is(false));

driver.findElement(By.id("buttonThatCallsAsynchronousFunction")).click(); // Ajax call that will change the DOM on successful return.

hasChanged = driver.findElement(By.id("somethingThatShouldChange"));
assertThat(hasChanged, is(true));</pre>
<p>Woops. <em>hasChanged</em> is modified when the Ajax function called by clicking <em>buttonThatCallsAsynchronousFunction</em> returns. But there wasn't enough time between the click and the assertion.</p>
<p><strong>A very poor solution is to use</strong> <strong>sleep </strong>to make sure that the asynchronous call has had enough time to return<strong>.</strong> The issue with sleep is that the sleep value needs to be as high as the highest value you can imagine the function could possibly need. If it's lower than this, the test might fail even if it was still working. If the asynchronous function finishes a lot quicker than in the worst case scenario, the test will just be hanging around wasting time.</p>
<p>Setting the sleep to 10 seconds to make sure <em>hasChanged</em> has changed value. If the asynchronous function triggered by <em>buttonThatCallsAsynchronousFunction</em> has finished before the sleep has, it just sits there waiting unnecessarily.</p>
<pre class="noescape prettyprint">driver.findElement(By.id("buttonThatCallsAsynchronousFunction")).click();
Thread.sleep(10);</pre>
<p>Instead, use <strong>polling</strong> to see if the hasChanged element has changed. Webdriver can wait for changes <a title="http://seleniumhq.org/docs/04_webdriver_advanced.html" href="http://seleniumhq.org/docs/04_webdriver_advanced.html">explicitly or implicitly</a>. In explicit waits, shown below, Webdriver polls the expected condition every 0.5 seconds.</p>
<pre class="noescape prettyprint">driver.findElement(By.id("buttonThatCallsAsynchronousFunction")).click();

hasChanged = (new WebDriverWait(driver, 10))
   .until(new ExpectedCondition&lt;WebElement&gt;() {
   @Override public WebElement apply(WebDriver d) {
     WebElement hasChangedPolled = d.findElement(By.id("somethingThatShouldChange");
         return (hasChangedPolled != null &amp;&amp; hasChangedPolled.getText() != null &amp;&amp; hasChangedPolled.getText().equals("true"));
}});</pre>
<div>
<p>There's lots of convenience methods for in <a title="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html" href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html">ExpectedConditions</a>, use them when possible to make your code more readable.The above use of WebdriverWait could've used this instead:</p>
<pre class="noescape prettyprint">hasChanged = wait.until(ExpectedConditions.textToBePresentInElement(By.id("somethingThatShouldChange"), "true"));</pre>
</div>
<h4>1.3. Isolate tests</h4>
<p>Basically, any test must be able to run several times in a row, and the whole suite must be able to run successfully regardless of order. Any changes made to anything that is shared must be changed back when the test has completed. Try using @BeforeClass, @Before, @After and @AfterClass for setup and tear downs. Things to think about during tear down are changes to the database, and static variables.</p>
<h3>2. Webdriver specific</h3>
<h4>2.1. Understanding Native events</h4>
<p>A project my team was working on recently had several flaky Webdriver tests. 99% of the time, they ran perfectly on any local machine, but failed every other time when running on a specific Selenium node. It had been doing so for a while when we were running the tests locally, and we noticed by coincidence that the test <strong>would only fail if we stole focus from the browser</strong> running it. This is exactly what happened when we ran it on our Selenium nodes, which sometimes has multiple regression suits running at the same time.</p>
<p>There's two types of events in Webdriver - <a title="http://code.google.com/p/selenium/wiki/AdvancedUserInteractions#Introduction" href="http://code.google.com/p/selenium/wiki/AdvancedUserInteractions#Introduction">native ones and synthetic ones</a>. <strong>Native events should be used whenever possible</strong>, as synthetic events are simulated Javascript actions as opposed to operating system events sent to the browser. Synthetic events may do unexpected things, such as being able to click on hidden objects. Some advanced Webdriver interactions require native events to be used.</p>
<p><a title="http://code.google.com/p/selenium/wiki/TipsAndTricks" href="http://code.google.com/p/selenium/wiki/NativeEventsOnLinux" target="_blank">Native Events</a> needs to be <a title="http://code.google.com/p/selenium/wiki/TipsAndTricks" href="http://code.google.com/p/selenium/wiki/TipsAndTricks" target="_blank">turned on manually</a> in <strong>Firefox for Linux</strong> because of its reliability issues <a title="http://code.google.com/p/selenium/wiki/NativeEventsOnLinux" href="http://code.google.com/p/selenium/wiki/NativeEventsOnLinux">relating to which window manager</a> is used. In essence, native events shouldn't need the browser to be focused to be able to run successfully. This is great since it enables us to run more than one Webdriver concurrently, as well as use other applications on the same machine while the test is running (if you're quick!). Some window managers still demand focus to allow for native events to work, and combined with issues of swapping focus between browsers, it renders it very difficult to run tests without turning to <a title="http://my.safaribooksonline.com/book/programming/javascript/0596101996/events-and-event-handling/jscript5-chp-17-sect-7" href="http://my.safaribooksonline.com/book/programming/javascript/0596101996/events-and-event-handling/jscript5-chp-17-sect-7">synthetic events</a> instead.</p>
<p>In essence, be aware when running Firefox on Linux.</p>
<h4>2.2. Using JavaScriptExecutor when necessary</h4>
<p>There's occasions when Webdriver doesn't interact with DOM elements as we're expecting. This might be because <strong>we believe an event will be triggered</strong>, for example the <a title="http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:_The_%22onchange%22_event_doesn%27t_fire_after_a_call" href="http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:_The_%22onchange%22_event_doesn%27t_fire_after_a_call">onchange event when using sendKeys</a> on an inputbox. It may also be that we're using a <strong>Javascript library</strong> such as <a title="http://www.knockoutjs.com" href="http://www.knockoutjs.com" target="_blank">Knockout</a> with its own set of triggers and handlers that doesn't mix with Webdriver very well. It may also be that the <strong>browser version we're running isn't yet supported</strong> by Webdriver, which happens a lot with Firefox. In this case, it can be necessary to run Javascript directly.</p>
<p>Changing the value of an input element with Javascript instead of using Webdriver's <a title="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebElement.html#sendKeys(java.lang.CharSequence...)" href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebElement.html#sendKeys(java.lang.CharSequence...)">sendKeys</a>.<em> </em></p>
<pre class="prettyprint noescape">WebElement inputBox = driver.findElement(By.id("inputBox"));
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executorScript("jQuery('#' + inputBox.getAttribute('id')").val("changed value"));</pre>
<h4>2.3. Be aware of any environmental differences between test slaves</h4>
<p>If you're running the regression test suite on several different machines (for example on a bunch of different <a title="http://selenium-grid.seleniumhq.org/" href="http://selenium-grid.seleniumhq.org/" target="_blank">Selenium nodes</a>), instability could be that the tests are running fine on all machines but one. On one occasion, we noticed that one of the test nodes constantly failed due to <strong>an automatically updated version of</strong> <strong>Firefox which wasn't compatible</strong> with Selenium.</p>
<p>As mentioned earlier, there's issues with using native events on Linux Firefox in combination with some window managers. This caused tests to fail on the Linux slave while running perfectly on a Windows slave. So the browser versions didn't even matter, they could've just as well been the same.</p>
<p>I think this is a decent beginning, but I'm sure there are more things that needs to be covered.</p>
